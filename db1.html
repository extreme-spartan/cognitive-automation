<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.8.0/Chart.min.js"></script>    
                
<canvas id="myChart" style="height:490px;width:90%;text-decoration-color:white;"></canvas>

<script>
var data1 = [5, 19, 3, 5, 2, 3, 20]
var data2 = [12, 19, 13, 15, 12, 13, 30]
var data3 = [21, 91, 131, 151, 121, 131, 40]
var data4 = [12, 19, 13, 15, 12, 13, 30]

var chartData = {
    type: 'bar',
    data: {
        labels: ["Apps", "Platform", "Storage", "Backup", "Security", "Network", "Database"],
       datasets: [{
          label: "P1",
          backgroundColor: 'rgba(255, 99, 132, 0.95)',
          data: data1
       }, {
          label: "P2",
          backgroundColor: 'rgba(54, 162, 235, 0.95)',
          data: data2
       }, {
          label: "P3",
          backgroundColor: 'rgba(255, 206, 86, 0.95)',
          data: data3
       }, {
          label: "P4",
          backgroundColor: 'rgba(255, 106, 86, 0.95)',
          data: data4
       }]
    },
    options: {
       responsive: false,
       legend: {
          display: false
       },
       scales: {
          yAxes: [{
             stacked: false,
                gridLines: {
                    display: true,
                    color: 'blue'
                },
                scaleLabel: {
                    display: true,
                    labelString: 'Event Count',
                    fontColor: 'blue',
                    fontSize: 14    
                },
                ticks: {
                    fontColor: "blue",
                    fontSize: 14
                } 
          }],
          xAxes: [{
             stacked: false,
                gridLines: {
                    display: false,
                    color: 'grey',
                },
                scaleLabel: {
                    display: true,
                    labelString: 'Cloud Infrastructure',
                    fontColor: 'blue',
                    fontSize: 20
                },
                ticks: {
                    fontColor: "blue",
                    fontSize: 14
                } 
          }]
       },
    "animation": {
      "duration": 0.1,
      "onComplete": function() {
        var chartInstance = this.chart,
        ctx = chartInstance.ctx;

        //ctx.font = Chart.helpers.fontString(Chart.defaults.global.defaultFontSize, Chart.defaults.global.defaultFontStyle, Chart.defaults.global.defaultFontFamily);
        ctx.fontSize = 2;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'center';
        ctx.fontColor = 'white';

        this.data.datasets.forEach(function(dataset, i) {
          var meta = chartInstance.controller.getDatasetMeta(i);
          meta.data.forEach(function(bar, index) {
            var data = dataset.data[index];
            ctx.fillText(data, bar._model.x, bar._model.y - 5);
          });
        });
      }
    },
        legend: {
                labels: {
                    fontColor: "black",
                    fontSize: 10
                },
                display: true
            },
        title: {
            display: true,
            text: "Live Events Categorization",
            fontColor: 'black',
            fontSize: 14,
            borderColor: '#000011'
        }
 
    }
 }
 
 var canvas = document.getElementById('myChart');
 var myChart = new Chart(canvas, chartData);
 
 canvas.onclick = function(evt) {
    var activePoint = myChart.getElementAtEvent(evt)[0];
    var selectedIndex = activePoint._index;

    var data = activePoint._chart.data;
    var datasetIndex = activePoint._datasetIndex;
    var squad = data.labels[selectedIndex];
    var label = data.datasets[datasetIndex].label;
    var value = data.datasets[datasetIndex].data[activePoint._index];
    alert(squad+' - '+label+'='+value);
    document.location.href="./db"+datasetIndex+".html"
 };
</script> -->

<!DOCTYPE html>
<html>
<head>
    <title>Incident Data Chart</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Modal styles */
        .modal {
          display: none;
          position: fixed;
          z-index: 1;
          left: 0;
          top: 0;
          width: 100%;
          height: 100%;
          overflow: auto;
          background-color: rgba(0, 0, 0, 0.7);
        }
        
        .modal-content {
          background-color: white;
          margin: 5% auto;
          padding: 15px;
          border: 1px solid #888;
          width: 70%;
        }
        
        .close {
          color: #aaa;
          float: right;
          font-size: 28px;
          font-weight: bold;
        }
        
        /* Slide-in pane styles */
        /* .slide-pane {
          position: fixed;
          top: 0;
          right: -400px;
          width: 400px;
          height: 100%;
          background-color: white;
          box-shadow: -3px 0 6px rgba(0, 0, 0, 0.3);
          transition: right 0.3s ease-in-out;
        } */
        
        .pane-content {
          padding: 10px;
        }
        
        /* .close-slide {
          color: #aaa;
          float: right;
          font-size: 28px;
          font-weight: bold;
          cursor: pointer;
        } */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1; /* Sit on top */
            padding-top: 10px; /* Location of the box */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
        }

        /* Modal content */
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 40px;
            border: 1px solid #888;
            max-width: 90%; /* Set a maximum width */
            max-height: 80%; /* Set a maximum height */
            overflow: auto; /* Allow vertical scrolling if content overflows */
        }

        /* Close button */
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        
        </style>

</head>
<body>
    <!-- Modal -->
    <div id="myModal" class="modal">
        <div class="modal-content">
        <span class="close">&times;</span>
        <canvas id="myChart"></canvas>
        </div>
    </div>
    <canvas id="stackedChart" style="height: 490px; width: 90%;"></canvas>
    <button id="recordBtn">Start Meeting</button> <button id="saveButton">Save Canvas as Image</button><input id="chatInput" type="text" class="form-control" placeholder="Type in text here .. " autofocus="autofocus" onkeyup="send_txt(id)" oninput="countCharacters()" style="width: 100%;"/>
    
    <script>

        const synth = window.speechSynthesis; // Initialize the synth object
        const canvas = document.getElementById("stackedChart");
        var vmData = [ 
            {
                squad_name: "APPS",
                incidents: {
                    New: { P1: 2, P2: 3, P3: 6, P4: 50, P5: 60  },
                    "In Progress": { P1: 2, P2: 5, P3: 7, P4: 3, P5: 1 },
                    Resolved: { P1: 8, P2: 12, P3: 18, P4: 10, P5: 5 },
                    Closed: { P1: 3, P2: 6, P3: 8, P4: 4, P5: 2 }
                }
            },
            {
                squad_name: "BACKUP",
                incidents: {
                    New: { P1: 5, P2: 10, P3: 15, P4: 8, P5: 3 },
                    "In Progress": { P1: 2, P2: 5, P3: 7, P4: 3, P5: 1 },
                    Resolved: { P1: 8, P2: 12, P3: 18, P4: 10, P5: 5 },
                    Closed: { P1: 3, P2: 6, P3: 8, P4: 4, P5: 2 }
                }
            },
            {
                squad_name: "LINUX",
                incidents: {
                    New: { P1: 5, P2: 10, P3: 15, P4: 8, P5: 3 },
                    "In Progress": { P1: 2, P2: 5, P3: 7, P4: 3, P5: 1 },
                    Resolved: { P1: 8, P2: 12, P3: 18, P4: 10, P5: 5 },
                    Closed: { P1: 3, P2: 6, P3: 8, P4: 4, P5: 2 }
                }
            },
            {
                squad_name: "NETWORK",
                incidents: {
                    New: { P1: 5, P2: 10, P3: 15, P4: 8, P5: 3 },
                    "In Progress": { P1: 2, P2: 5, P3: 7, P4: 3, P5: 1 },
                    Resolved: { P1: 8, P2: 12, P3: 18, P4: 10, P5: 5 },
                    Closed: { P1: 3, P2: 6, P3: 8, P4: 4, P5: 2 }
                }
            },
            {
                squad_name: "SECURITY",
                incidents: {
                    New: { P1: 2, P2: 3, P3: 6, P4: 50, P5: 60  },
                    "In Progress": { P1: 2, P2: 5, P3: 7, P4: 3, P5: 1 },
                    Resolved: { P1: 8, P2: 12, P3: 18, P4: 10, P5: 5 },
                    Closed: { P1: 3, P2: 6, P3: 8, P4: 4, P5: 2 }
                }
            },
            {
                squad_name: "STORAGE",
                incidents: {
                    New: { P1: 5, P2: 10, P3: 15, P4: 8, P5: 3 },
                    "In Progress": { P1: 2, P2: 5, P3: 7, P4: 3, P5: 1 },
                    Resolved: { P1: 8, P2: 12, P3: 18, P4: 10, P5: 5 },
                    Closed: { P1: 3, P2: 6, P3: 8, P4: 4, P5: 2 }
                }
            },
            {
                squad_name: "WINDOWS",
                incidents: {
                    New: { P1: 5, P2: 10, P3: 15, P4: 8, P5: 3 },
                    "In Progress": { P1: 2, P2: 5, P3: 7, P4: 3, P5: 1 },
                    Resolved: { P1: 8, P2: 12, P3: 18, P4: 10, P5: 5 },
                    Closed: { P1: 3, P2: 6, P3: 8, P4: 4, P5: 2 }
                }
            }
        ];

        // Extract unique categories and severities
        var categories = Object.keys(vmData[0].incidents);
        var severities = Object.keys(vmData[0].incidents[categories[0]]);

        // alert(severities)

        var storedValues = [];
        var storedValues2 = [];
        // Create labels for the chart (squad names)
        // var squadNames = vmData.map(squad => squad.squad_name);
        // Extract unique squad names
        var squadNames = vmData.map(item => item.squad_name);

        // Create data for the chart
        var datasets = [];
        var categoryColors = {
            New: 'red',
            "In Progress": 'yellow',
            Resolved: 'green',
            Closed: 'blue',
            Predicted: 'cyan' // New color for predicted incidents
        };
        // Function to get color based on category
        function getColor(category, severity) {
            // getColor2(severity);
            // Return colors based on category
            // You can customize the colors here
            // alert(category +" "+severity);
            if (category === "New") return "rgba(255, 0, 0, 0.8)";
            if (category === "In Progress") return "rgba(255, 165, 0, 0.8)";
            if (category === "Resolved") return "rgba(255, 255, 0, 0.8)";
            if (category === "Closed") return "rgba(0, 128, 0, 0.8)";
            // if (category === "Re_Opened") return "rgba(0, 0, 255, 0.8)";
            if (severity === "P1") return "rgba(55, 0, 0, 0.8)";
            if (severity === "P2") return "rgba(255, 165, 0, 0.8)";
            if (severity === "P3") return "rgba(255, 155, 0, 0.8)";
            if (severity === "P4") return "rgba(10, 128, 0, 0.8)";
            if (severity === "P5") return "rgba(0, 0, 25, 0.8)";
        }

        var labels = vmData.map(vm => vm.vm);
        var datasets = categories.map(category => {
            return {
                // label: [category, severities],
                label: [category],
                data: vmData.map(vm => calculateCategoryTotal(vm.incidents, category)),
                backgroundColor: severities.map(severity => getColor(category)),
                borderWidth: 1
            };
        });        
        var pi = [];
        // Function to calculate total incidents for a category across all severities
        function calculateCategoryTotal(incidents, category) {
            totalSum = Object.values(incidents[category]).reduce((total, severity) => total + severity, 0);
            // alert(totalSum)
            return totalSum;
        }
 
        // Create a bar chart using Chart.js
        var ctx = canvas.getContext('2d');

        const config = {
            type: 'bar',
            data: {
                labels: squadNames,
                datasets: datasets
            },
            options: {
                scales: {
                    y: {
                        beginAtZero: true
                    }
                },
            animation: {
                duration: 0.1,
                onComplete: function (chart) {
                    
                    const datasets = stackedChart.data.datasets;
                    ctx.font = "12px sans-serif";
                    ctx.fillStyle = "black";
                    ctx.textAlign = "center";
                    // var squadsTeams = squadNames;
                    // Extract unique squad names
                    var squadsTeams = vmData.map(item => item.squad_name);

                    for (let i = 0; i < datasets.length; i++) {
                        console.log(datasets.length);

                        const meta = stackedChart.getDatasetMeta(i);
                        meta.data.forEach((bar, index) => {
                            var squad = squadsTeams[index];
                            // alert(squad)
                            
                            var data = datasets[i].data[index];;
                            var lbl = datasets[i].label;
                            
                            const value = datasets[i].data[index];
                            const x = bar.x;
                            const y = bar.y +7 ; // Adjust the vertical position
                            console.log(squad, lbl, value);
                            ctx.fillText(value, x, y);
                            if (storedValues.length < 35) {
                            storedValues.push({ squad: squad, label: lbl, data: data, x: x, y: y });
                            console.log(storedValues.length);
                            
                            }
                        });
                    }
                }
            },
            plugins: {
                title: {
                    display: true,
                    color: "blue",
                    font: {size: 14},
                    text: 'Daily Incident Status',
                    padding: {
                        top: 10,
                        bottom: 10
                    },

                }
            }
        }
    };

    const stackedChart = new Chart(canvas, config);

    // Sample past data for prediction
    const pastData = [100, 150, 200, 250, 300, 350, 400];

    // Function to predict severity based on past performance
    function predictSeverity(pastData) {
        // Add your prediction logic here (e.g., using machine learning models)

        // For simplicity, let's assume we add 10% to the past data for prediction
        return pastData.map(value => Math.round(value * 1.1));
    }
    
    // Calculate predicted incidents
    var predictedData = vmData.map(vm => Math.round(calculateCategoryTotal(vm.incidents, 'New') * 1.1));
    // var predictedData = vmData.map(squad => severities.map(severity => Math.round(squad.incidents.New[severity] * 1.1)));
    // alert(predictedData)
    
    datasets.push({
        label: 'Predicted',
        data: [].concat.apply([], predictedData), // Flatten the nested array
        backgroundColor: categoryColors.Predicted,
        // borderColor: categoryColors.Predicted,
        borderWidth: 1
    });

    stackedChart.update();

    // Function to retrieve values with a delay
    function retrieveValuesWithDelay(delay) {
        // Sort the storedValues array based on the "squad" property
        storedValues.sort((a, b) => a.squad.localeCompare(b.squad));

        // Now you can retrieve the sorted values with a delay
        storedValues.forEach((item, index) => {
            const squad = item.squad;
            const label = item.label;
            const data = item.data;
            const x = item.x;
            const y = item.y;
            
            // Retrieve the values after a delay of 7 seconds for each iteration
            setTimeout(() => {
                console.log(`Squad: ${squad}, Label: ${label}, Data: ${data}, X: ${x}, Y: ${y}`);
                var mouseMoveEvent = new MouseEvent("mousemove", {
                            bubbles: true,
                            cancelable: true,
                            clientX: x,
                            clientY: y + 3,
                        });

                        canvas.dispatchEvent(mouseMoveEvent);
                        

                        // Use text-to-speech to announce the status and severity for each squad
                        if (label == "New") {
                            announcementText = `For ${squad}: we have ${data}: ${label} incidents.`;
                            canvas.click();
                        } else if (label == "Resolved") {
                            announcementText = `We have ${data} incidents ${label} for ${squad}.`;
                        } else if (label == "In Progress") {
                            announcementText = `The ${squad} Squad has ${data} incidents which are ${label}`;
                        } else if (label == "Closed") {
                            announcementText = `Total incidents ${label} by ${squad} Squad are around ${data}.`;
                        } else if (label == "Re-opened") {
                            announcementText = `${squad}: ${label}: ${data} incidents re-opened.`;
                        } else if (label == "Predicted") {
                            announcementText = `The Overall ${label}: number of incidents for ${squad} Squad is around ${data}.`;
                        } else {
                            announcementText = `${squad}: ${label}: ${data} incidents.`;
                        }

                        speakWithBuffer(announcementText);
                        if (index == 34){
                            recordBtn.click();
                        }
   
            }, index * 7000); // Delay of 7 seconds (7000 milliseconds)
        });
        
    }

        // Announce the predicted severity after 3 seconds
        // setTimeout(retrieveValuesWithDelay, 7000);

        // const canvas = document.getElementById('canvas');
        const context = canvas.getContext("2d");
        const recordBtn = document.querySelector("button");

        let recording = false;
        let mediaRecorder;
        let recordedChunks = [];
        let audioBuffers = [];

        recordBtn.addEventListener("click", async () => {
            recording = !recording;
            if (recording) {
                recordBtn.textContent = "Stop Meeting";
                const stream = canvas.captureStream(25);
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'video/webm;codecs=vp8',
                    ignoreMutedMedia: true
                });
                recordedChunks = [];
                audioBuffers = [];

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        recordedChunks.push(e.data);
                    }
                };

                mediaRecorder.start();
                
                // Start recording canvas events and text-to-speech audio
                startCanvasEventRecording();
                
            } else {
                recordBtn.textContent = "Start Meeting";
                mediaRecorder.stop();

                // Stop recording canvas events and text-to-speech audio
                stopCanvasEventRecording();

            }
        });

// Function to start recording canvas events and text-to-speech audio
function startCanvasEventRecording() {
    // var delay = 3000;
    speakWithBuffer("Hi Squad Leaders and others, Thanks for joining the Daily Incident Status Meeting.");
    setTimeout(retrieveValuesWithDelay, 5000);
    // canvas.addEventListener("mousemove", handleMouseMove);
}

// Function to stop recording canvas events and text-to-speech audio
async function stopCanvasEventRecording() {
    var storedValues = [];
    const announcementText = "Thanks for attending the meeting, the session is now open for questions and clarification.";
    const bufferArray = await speakWithBuffer(announcementText);
    console.log("Received bufferArray:", bufferArray);
    audioBuffers.push(...(Array.isArray(bufferArray) ? bufferArray : [bufferArray]));

    // Ensure that audioBuffers are populated before proceeding
    if (recordedChunks.length > 0 && audioBuffers.length > 0) {
        // const combinedBlob = await mergeAudioBuffers(audioBuffers) //mergeVideoAndAudio(recordedChunks, audioBuffers);
        const combinedBlob = await mergeVideoAndAudio(recordedChunks, audioBuffers);
        const url = URL.createObjectURL(combinedBlob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "canvas_recording_with_audio.webm";
        a.click();
        URL.revokeObjectURL(url);
        
    } else {
        console.log("audioBuffers array is empty.");
    }
}

// Function to merge video and audio
async function mergeVideoAndAudio(videoChunks, audioBuffers) {
    const videoBlob = new Blob(videoChunks, { type: 'video/webm' });

    const audioContext = new (window.AudioContext || window.webkitAudioContext)(); // Create an AudioContext

    // Check if audioBuffers is an array and not empty
    if (!Array.isArray(audioBuffers) || audioBuffers.length === 0) {
        throw new Error('Invalid or empty audioBuffers array.');
    }

    // Create an OfflineAudioContext for rendering the combined audio
    const offlineAudioContext = new OfflineAudioContext({
        numberOfChannels: audioBuffers[0].numberOfChannels,
        length: audioBuffers[0].length * audioBuffers.length,
        sampleRate: audioBuffers[0].sampleRate,
    });

    audioBuffers.forEach((audioBuffer, index) => {
        const source = offlineAudioContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(offlineAudioContext.destination);
        source.start(index * audioBuffer.length);
    });

    // Start the rendering process
    const renderedAudioBuffer = await offlineAudioContext.startRendering();

    const audioBufferArrayBuffer = audioBufferToWavArrayBuffer(renderedAudioBuffer);
    const audioUint8Array = new Uint8Array(audioBufferArrayBuffer);

    const audioBlob = new Blob([audioUint8Array], { type: 'audio/wav' });

    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = async () => {
            const audioArrayBuffer = reader.result;
            const videoArrayBuffer = await videoBlob.arrayBuffer();
            const videoUint8Array = new Uint8Array(videoArrayBuffer);

            const combinedUint8Array = new Uint8Array(videoUint8Array.length + audioArrayBuffer.byteLength);
            combinedUint8Array.set(videoUint8Array, 0);
            combinedUint8Array.set(new Uint8Array(audioArrayBuffer), videoUint8Array.length);

            resolve(new Blob([combinedUint8Array], { type: 'video/webm' }));
        };
        reader.readAsArrayBuffer(audioBlob);
    });
}


// Handle mouse move event
function handleMouseMove(event) {
    // ... (your canvas event handling logic)

    const announcementText = "Your announcement text here";
    speakWithBuffer(announcementText).then(bufferArray => {
        audioBuffers.push(...bufferArray);
    });
}

// Function to speak and return an audio buffer
async function speakWithBuffer(text) {
    return new Promise(async (resolve, reject) => {
        try {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-US';

            const audioContext = new (window.AudioContext || window.webkitAudioContext)();

            const analyserNode = audioContext.createAnalyser();
            analyserNode.fftSize = 2048;
            const bufferLength = analyserNode.frequencyBinCount;
            const dataArray = new Float32Array(bufferLength);

            const source = audioContext.createBufferSource();
            source.connect(analyserNode);
            analyserNode.connect(audioContext.destination);

            const chunks = [];

            utterance.onend = async () => {
                source.stop();
                analyserNode.disconnect();
                const audioBuffer = audioContext.createBuffer(1, chunks.length * bufferLength, audioContext.sampleRate);
                const audioBufferChannelData = audioBuffer.getChannelData(0);

                for (let i = 0; i < chunks.length; i++) {
                    audioBufferChannelData.set(chunks[i], i * bufferLength);
                }

                resolve(audioBuffer);
            };

            source.onended = () => {
                resolve(null); // Resolve with null if playback ends unexpectedly
            };

            source.start();

            // Capture audio data using analyserNode
            function captureAudioData() {
                analyserNode.getFloatTimeDomainData(dataArray);
                chunks.push(new Float32Array(dataArray));
                requestAnimationFrame(captureAudioData);
            }

            captureAudioData();

            synth.speak(utterance);
        } catch (error) {
            console.error("Error in speakWithBuffer:", error);
            reject(error);
        }
    });
}
function audioBufferToWavArrayBuffer(audioBuffer) {
    const numChannels = audioBuffer.numberOfChannels;
    const sampleRate = audioBuffer.sampleRate;
    const numFrames = audioBuffer.length;
    const samples = new Float32Array(numFrames * numChannels);

    for (let channel = 0; channel < numChannels; channel++) {
        const channelData = audioBuffer.getChannelData(channel);
        samples.set(channelData, channel * numFrames);
    }

    const buffer = new ArrayBuffer(44 + samples.length * 2);
    const view = new DataView(buffer);

    // RIFF chunk descriptor
    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + samples.length * 2, true);
    writeString(view, 8, 'WAVE');

    // Format chunk
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * numChannels * 2, true);
    view.setUint16(32, numChannels * 2, true);
    view.setUint16(34, 16, true);

    // Data chunk
    writeString(view, 36, 'data');
    view.setUint32(40, samples.length * 2, true);

    // Write the PCM samples
    floatTo16BitPCM(view, 44, samples);

    return buffer;
}

function writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
    }
}

function floatTo16BitPCM(output, offset, input) {
    for (let i = 0; i < input.length; i++, offset += 2) {
        const s = Math.max(-1, Math.min(1, input[i]));
        output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    }
}

    canvas.addEventListener("click", function(evt) {
        var activePoint = stackedChart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);

        if (activePoint.length > 0) {
            var datasetIndex = activePoint[0].datasetIndex;
            var selectedIndex = activePoint[0].index;
            var squad = stackedChart.data.labels[selectedIndex];
            var label = stackedChart.data.datasets[datasetIndex].label;
            var value = stackedChart.data.datasets[datasetIndex].data[selectedIndex];
            // alert(`Squad: ${squad}\nSeverity: ${label}\nCount: ${value}`);
            console.log('>>>>>>>>>>>>>>>>>>>>>>', squad);
            var modal = document.getElementById("myModal");
            var span = document.getElementsByClassName("close")[0];
            modal.style.display = "block";

            // For Slide-in Pane
            // var slidePane = document.getElementById("slidePane");
            // slidePane.style.right = "0";
            var sn = vmData.map(vm => vm.squad_name);

            function calculateSeverityTotal(vmData, squad, category, severity) {
                const squadData = vmData.find(vm => vm.squad_name === squad);
                if (squadData) {
                    return squadData.incidents[category][severity];
                }
                return 0;
            }

            var datasets = severities.map(severity => {
                return {
                    label: severity,
                    data: categories.map(category => calculateSeverityTotal(vmData, squad, category, severity)),
                    backgroundColor: getColor(severity),
                    borderWidth: 1
                };
            });



            var chartData2 = {
                type: 'bar',
                scales: {
                    x: {
                        stacked: false
                    },
                    y: {
                        stacked: false
                    }
                },
                data: {
                    labels: categories,
                    datasets: datasets
                },
                options: {
                    "animation": {
                    "duration": 0.1,
                    onComplete: function (chart) {
                        const datasets = myChart.data.datasets;
                        
                        ctx2.font = "12px sans-serif";
                        ctx2.fillStyle = "black";
                        ctx2.textAlign = "center";
                        // var squadsTeams = stackedChart.data.labels;

                        for (let i = 0; i < datasets.length; i++) {
                            const meta = myChart.getDatasetMeta(i);
                            meta.data.forEach((bar, index) => {
                                // var squad = squadsTeams[index];
                                // var data = datasets[i].data[index];;
                                // var lbl = datasets[i].label;

                                const value = datasets[i].data[index];
                                const x = bar.x;
                                const y = bar.y +7 ; // Adjust the vertical position

                                ctx2.fillText(value, x, y);
                                // storedValues.push({ squad: squad, label: lbl, data: data, x: x, y: y });
                            });
                        }
                    }
                    },
                    plugins: {
                        title: {
                            display: true,
                            color: "blue",
                            font: {size: 14},
                            text: 'Incident Severity Break-up Report for: '+squad+ ' Squad',
                            padding: {
                                top: 10,
                                bottom: 10
                            },

                        }
                    }
                }
            };

            var canvas2 = document.getElementById('myChart');
            var ctx2 = canvas2.getContext('2d');
            var myChart = new Chart(ctx2, chartData2);

            // Close modal or slide-in pane when the close button is clicked
            span.onclick = function() {
                modal.style.display = "none";
                if (typeof myChart !== 'undefined' && myChart !== null) {
                    myChart.destroy(); // Destroy the existing chart instance
                        // Restore canvas dimensions to initial values
                    myChartCanvas.width = initialMyChartWidth;
                    myChartCanvas.height = initialMyChartHeight;
                }
                // slidePane.style.right = "-400px";
            };
        }
    });

    window
        .addEventListener(
            'load',
            function() {
              //showVButtons('none');
              //updateImage('');
            //   var c = document.querySelector('canvas');
              
            //   alert(c.id);
              // Get the canvas element
            //   const canvas = document.getElementById("defaultCanvas0");

              // Get the label element
            //   const aside = document.getElementById("asideLabel");
              
              // Move the canvas inside the label
            //   aside.appendChild(canvas);

              // Shp = "onload"
              // document.getElementById("toggle").click();
              // document.getElementById("panel").style.display = "none";
                 
                  // siteControls(inputText);  




            //   initiate(assistantid);

            //   historyArea.value += 
            //           "me>> "+ "You're not authenticated :(" + "\n";
            //       historyArea.scrollTop = historyArea.scrollHeight; 

              // document.getElementById("spnChart").style.display = "none";
              // const canvas = document.getElementById("defaultCanvas0");
              // const canvasContainer = document.getElementById("canvasContainer");
              // if (canvas && canvasContainer) {
              //     canvasContainer.appendChild(canvas);
              // }
              // uvid.src="https://cdn2.veltra.com/ptr/20180427105257_558150640_10498_0.jpg";
            //   waitImg.src="";
            //   uvid.style.display = "block"; 
              // usrImg.src="https://cdn2.veltra.com/ptr/20180427105257_558150640_10498_0.jpg";
            //   cmsImg.src="";  //"https://responsivevoice.org/wp-content/uploads/2020/01/parrot-flight.png"
              //startButton(event);
              // sendConverse("Jargon of the day");

              // setTimeout('loadJson("' + BASE_CMS_URL + '/content/json/escape101.json")', imagePlayInterval);

            });
    
    (function() {
      document
          .getElementById('chatInput')
          .addEventListener(
              'keydown',
              function(e) {
                if (e.keyCode === 13) {
                  //send_button.style.display = 'none';
                  var inputText = this.value;
                  if (inputText != ""){
                    alert(inputText);
                    var c = document.querySelector('canvas');
                    
                    // alert(c.id);
                    if (inputText == "save"){
                        saveButton.click()
                    }
                //     historyArea.value += 
                //       'me>> '+ inputText + '\n';
                //     historyArea.scrollTop = historyArea.scrollHeight;                  
                //   // siteControls(inputText);  
                //     sendConverse(inputText);
                  }
                  this.value = ''; 
                }
                if (e.keyCode === 27) {
                  sendConverse("CLEAR");
                }  
                // if (e.keyCode === 37) {
                //   sendConverse("MOVE LEFT");
                // }   
                // if (e.keyCode === 38) { 
                //   sendConverse("MOVE TOP");
                // }
                // if (e.keyCode === 39) {
                //   sendConverse("MOVE RIGHT");
                // }   
                // if (e.keyCode === 40) {
                //   sendConverse("MOVE DOWN");
                // }  
              });
    })();
    // Save the canvas as an image when the button is clicked
    saveButton.addEventListener('click', () => {
      const imageDataURL = canvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = imageDataURL;
      a.download = 'bargraph.png';
      a.click();
    });

    </script>
    <!-- <script src="./public/scripts/escape_js.js"></script> -->
</body>
</html>
